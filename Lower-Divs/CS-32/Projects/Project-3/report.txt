1. 
// Actor
Actor() - For my Actor constructor, I chose to pass in an image ID, starting location, starting direction, depth and a pointer to StudentWorld. For all parameters other than the pointer, I noticed that different derived classes would have different values for each of these, and it was therefore necessary to be able to change them based on what derived class I was using. For the pointer to StudentWorld, I noticed many of the derived classes needed to be able to refer back to the world they were in in order to interact with other actors, so I decided to store this in the base Actor class. This constructor also initializes the alive/dead status as alive, as all Actors are alive when created.

~Actor() - My Actor destructor has an empty body, as there is no dynamically allocated data stored within the class. I chose to make it a pure virtual function as a way to tell that the class is an abstract base class.

doSomething() - My doSomething() function is a pure virtual function, as a generic Actor should never be created, and therefore cannot do anything, but I wanted it to be a requirement for any derived classes to contain this function.

blocksSpawns() - My blocksSpawns() function is a virtual function that tells the caller whether or not the object is intended to block the spawning of other objects during initialization of the game. By default this returns false, but I chose to make it virtual as Pits and Food can block the spawning of Pits, Food, and DirtPiles, and I needed a way to make sure no overlaps occurred.

isDamageable() - My isDamageable() function is a virtual function that tells the caller whether or not the Actor can receive damage from Projectiles. By default, this returns true, but I chose to make it virtual as Pits, Food, and other Projectiles cannot be damaged by Projectiles, and I needed a way to make sure the game exhibited this behavior.

isFood() - My isFood() function is a virtual function that tells the caller whether or not the object is a Food object. By default this returns false, but I chose to make it virtual so that this return value can be overridden by food objects. This is in my base Actor class so that Bacteria can check if they are overlapping with Food so they can eat it, and this is most easily done by iterating through a list of Actor*s found in StudentWorld.

isDirt() - My isDirt() function is a virtual function that tells the caller whether or not the object is a DirtPile object. By default this returns false, but I chose to make it virtual so that this return value can be overridden by dirt objects. This is in my base Actor class so that bacteria can check if they are overlapping with DirtPiles, and are therefore not allowed to move to a specific location, and this is most easily done by iterating through a list of Actor*s found in StudentWorld.

isEnemy() - My isEnemy() function is a virtual function that tells the caller whether or not the object is an enemy. By default this returns false, but I chose to make it virtual so it can be overridden by Pits and Bacteria. This is in my base Actor class so that the StudentWorld can constantly check if there are any enemies remaining by iterating through a list of Actor*s in order to determine whether or not the level is over.

takeDamage() - My takeDamage() function is a virtual function that allows the object to take damage. By default, this function immediately sets the object to dead, as the majority of objects (Goodies, DirtPiles, etc.) are either dead or alive, so if they take damage, they die instantly. However, I made this virtual so that it could be overridden by Socrates and Bacteria, which both have health points, and therefore can take multiple hits. This is in my base Actor class so that the StudentWorld can make objects take damage after detecting certain overlaps (Projectile with enemy, enemy with Socrates, etc.)

getDead() - My getDead() function simply returns if the object is dead or alive. This allows me to use StudentWorld to check if the player is alive and for dead Actors that need to be be deleted. This is not virtual as all actors would use this function in the same way.

setDead() - My setDead() function sets the status of an Actor to dead. This allows for StudentWorld and derived classes to modify the dead/alive status when necessary. This function is not virtual, as it behaves the same way, regardless of what type of Actor is is used on.

getWorld() - My getWorld() function returns a pointer to the StudentWorld that the Actor is in. This allows for derived classes to obtain this pointer and therefore interact with the StudentWorld and its other actors. This function is not virtual, as it behaves the same way, regardless of what type of actor is is used on.

// Socrates
Socrates() - My Socrates constructor takes a pointer to StudentWorld as the parameter, so that the player has a way to access the world they're in and interact with other actors. The constructor uses the base Actor constructor to initialize itself with the correct image ID, a position of (0, VIEW_HEIGHT / 2), and the correct direction and depth. The body of the constructor initializes Socrates' health at 100, flamethrower charges at 5 and spray ammo at 20.

~Socrates() - My Socrates destructor has an empty body as Socrates objects have no dynamically allocated data.

doSomething() - My Socrates class' doSomething() function returns if the player is dead. Otherwise, it takes in user input if there is any and perform the correct action with a switch statement. If the user input is a directional key, Socrates will move 5 degrees in the desired direction. If the input is the spacebar, the function will initialize a new Spray actor in the correct location and direction if there is spray ammo remaining and update the addition to StudentWorld. If the input is the enter key, the function will initialize 16 Flame actors in the correct locations and directions and update the addition to StudentWorld. if there is no input, then the function regenerates Socrates' spray ammo by 1.

takeDamage() - Socrates' takeDamage() function overrides the virtual function provided in the base Actor class, as Socrates has health points that allow him to take multiple hits before dying. If the damage received would put Socrates to a negative amount of health, his health is set to 0. Otherwise, his health is decremented by the indicated amount. If his health is 0, then the function sets Socrates' status to dead and notifies the StudentWorld to decrement his lives.

getHealth() - Socrates' getHealth() function returns Socrates' health, allowing for the StudentWorld to access it in order to update the display at the top of the screen.

getSprays() - Socrates' getSprays() function returns Socrates' spray ammo, allowing for the StudentWorld to access it in order to update the display at the top of the screen.

getFlames() - Socrates' getFlames() function returns Socrates' flame ammo, allowing for the StudentWorld to access it in order to update the display at the top of the screen.

heal() - Socrates' heal() function resets Socrates' health to 100, allowing the StudentWorld to restore his health to full when he picks up a HealthKit. 

regenFlames() - Socrates' regenFlames() function adds 5 flame ammo to Socrates, allowing the StudentWorld to add flame ammo when he picks up a FlameCharge.

// DirtPile
DirtPile() - My DirtPile constructor takes in an initial position and a pointer to the world it is created in. It uses the base Actor constructor to initialize itself with the correct image ID, the provided location, and the correct direction and depth. 

~DirtPile() - My DirtPile destructor has an empty body, as DirtPile contains no dynamically allocated data.

doSomething() - My DirtPile's doSomething() function has an empty body because DirtPiles do not do anything during a tick.

isDirt() - My DirtPile's isDirt() function overrides the virtual function provided in the base Actor class, as DirtPiles need to be recognized as Dirt by bacteria. Therefore, this function returns true instead of false.

// Food
Food() -  My Food constructor takes in an initial position and a pointer to the world it is created in. It uses the base Actor constructor to initialize itself with the correct image ID, the provided location, and the correct direction and depth.

~Food() - My Food destructor has an empty body, as Food contains no dynamically allocated data.

doSomething() - My Food's doSomething() function has an empty body because Food does not do anything during a tick.

blocksSpawns() - My Food's blocksSpawns() function overrides the virtual function provided in the base Actor class, as Food blocks spawning of other Food objects and DirtPiles during initialization, and the StudentWorld needs a way to be aware of this. Therefore this function returns true instead of false.

isDamageable() - My Food's isDamageable() function overrides the virtual function provided in the base Actor class, as Food is not damageable and therefore must not block Projectiles, and the StudentWorld needs a way to be aware of this. Therefore, this function returns false instead of true.

isFood() - My Food's isFood() function overrides the virtual function provided in the base Actor class, as Food exhibits unique behavior when overlapping with Bacteria, and the StudentWorld needs a way to be aware of this. Therefore, this function returns true instead of false.

// Projectile
Projectile() - My Projectile constructor takes in an image ID, initial position, initial direction, maximum distance, damage value, and a pointer to StudentWorld. It uses the base Actor constructor to initialize itself with the provided image ID, position, direction, depth, and StudentWorld pointer. It also initializes the maximum distance of the Projectile with the provided max distance, the distance traveled of the Projectile as 0, and the Projectile's damage with the provided damage value.

~Projectile() - My Projectile destructor has an empty body, as there is no dynamically allocated data stored within the class. I chose to make it a pure virtual function as a way to tell that the class is an abstract base class.

doSomething() - My Projectile's doSomething() function returns if the Projectile is dead. Otherwise, it checks if it has overlapped with anything that can take damage and, if it has, it sets itself to dead and does damage to the other Actor. If no overlap occurred, the Projectile moves forward a distance of SPRITE_WIDTH in the direction it is currently pointing in. If, after this change, the Projectile has moved its maximum distance, it sets itself to dead. This function is used by both the Flame and Spray classes, as during a tick, they both exhibit the same behavior.

isDamageable() - My Projectile's isDamageable() function overrides the virtual function provided in the base Actor class, as Projectiles are not damageable and therefore must not block other Projectiles, and the StudentWorld needs a way to be aware of this. Therefore, this function returns false instead of true.

// Flame
Flame() - My Flame constructor takes in an initial position, direction, and pointer to the world it's in. It uses the base Projectile constructor to initialize itself with the correct image ID, position, direction, maximum distance, and damage value.

~Flame() - My Flame destructor has an empty body, as there is no dynamically allocated data stored within the class.

// Spray
Spray() - My Spray constructor takes in an initial position, direction, and pointer to the world it's in. It uses the base Projectile constructor to initialize itself with the correct image ID, position, direction, maximum distance, and damage value.

~Spray() - My Spray destructor has an empty body, as there is no dynamically allocated data stored within the class.

// Goodies
Goodies() - My Goodies constructor takes in an image ID, position, pointer to StudentWorld, and lifetime length. It uses the base Actor constructor to initialize itself with the correct image ID, position, direction, depth, and StudentWorld pointer. It also initializes its lifetime with the provided lifetime length. 

~Goodies() - My Goodies destructor has an empty body, as there is no dynamically allocated data stored within the class. I chose to make it a pure virtual function as a way to tell that the class is an abstract base class.

doEffect() - My Goodies' doEffect function is a pure virtual function as an ambiguous Goodie should never appear, and all Goodies have a different effect on the game. Therefore, I want it to be required for all derived classes of Goodies to implement this function.

doSomething() - My Goodies' doSomething() function returns if the Goodie is dead. Otherwise, the Goodie checks if it is overlapping with Socrates, and, if it is, it sets itself to dead and calls doEffect, which has a different effect depending on the type of Goodie. If the Goodie is not overlapping with Socrates, it decrements its lifetime. If after this, the lifetime is 0, the Goodie sets itself to dead.

// HealthKit
HealthKit() - My HealthKit constructor takes in a position, a pointer to StudentWorld, and a lifespan. It uses the base Goodies constructor to initialize itself with the correct image ID, position, StudentWorld pointer, and lifetime. 

~HealthKit() - My HealthKit destructor has an empty body, as there is no dynamically allocated data stored within the class.

doEffect() - My HealthKit's doEffect() function plays the correct sound, tells the StudentWorld to restore Socrates' health to full, and tells the StudentWorld to increase the player's score by 250.

// FlameCharge
FlameCharge() - My FlameCharge constructor takes in a position, a pointer to StudentWorld, and a lifespan. It uses the base Goodies constructor to initialize itself with the correct image ID, position, StudentWorld pointer, and lifetime. 

~FlameCharge() - My FlameCharge destructor has an empty body, as there is no dynamically allocated data stored within the class.

doEffect() - My FlameCharge's doEffect() function plays the correct sound, tells the StudentWorld to give Socrates 5 more flame ammo, and tells the StudentWorld to increase the player's score by 300.

// ExtraLife
ExtraLife() - My ExtraLife constructor takes in a position, a pointer to StudentWorld, and a lifespan. It uses the base Goodies constructor to initialize itself with the correct image ID, position, StudentWorld pointer, and lifetime. 

~ExtraLife() - My ExtraLife destructor has an empty body, as there is no dynamically allocated data stored within the class.

doEffect() - My ExtraLife's doEffect() function plays the correct sound, tells the StudentWorld to give the player 1 more life, and tells the StudentWorld to increase the player's score by 500.

// Fungus
Fungus() - My Fungus constructor takes in a position, a pointer to StudentWorld, and a lifespan. Although it is not a Goodie, it has the same general behavior as Goodies, so it uses the base Goodies constructor to initialize itself with the correct image ID, position, StudentWorld pointer, and lifetime. 

~FlameCharge() - My Fungus destructor has an empty body, as there is no dynamically allocated data stored within the class.

doEffect() - My Fungus' doEffect() function tells the world to do 20 damage to Socrates and tells the StudentWorld to decrease the player's score by 50, or decrease the score to 0 if the score would be negative after this change.

// Pit
Pit() - My Pit constructor takes in a position and a pointer to StudentWorld. It uses the base Actor constructor to initialize itself with the correct image ID, position, direction, depth, and StudentWorld pointer. It also initializes its inventory of Bacteria by seeing the number of AggSalmonella to 3, Salmonella to 5, and EColi to 2.

~Pit() - My Pit destructor has an empty body, as there is no dynamically allocated data stored within the class.

doSomething() - My Pit's doSomething() function first checks if it has an empty inventory, and, if it does, sets itself to dead and returns. Otherwise, it generates a random number between 1 and 50, and if that number is equal to 1 (1/50 chance) it will set itself as ready to spawn a Bacteria. It will generate a random number between 1 and 3 (so there is an equal chance to spawn each type of Bacteria), and then check if there is any of that type of Bacteria available. If there is, the Bacteria type will be spawned, the StudentWorld will be updated with this addition, the Bacteria type will be decremented in the Pit's inventory, and the Pit will no longer be ready to spawn anything. If there is no more of the type available, the loop will repeat and a new number between 1 and 3 will be generated. Afterwards, the Pit plays the correct sound for a new Bacteria being born.

blocksSpawns() - My Pit's blocksSpawns() function overrides the virtual function provided in the base Actor class, as Pit blocks spawning of other Pits, Food, and DirtPiles during initialization, and the StudentWorld needs a way to be aware of this. Therefore this function returns true instead of false.

isDamageable() - My Pit's isDamageable() function overrides the virtual function provided in the base Actor class, as Pits are not damageable and therefore must not block Projectiles, and the StudentWorld needs a way to be aware of this. Therefore, this function returns false instead of true.

isEnemy() - My Pit's isEnemy() function overrides the virtual function provided in the base Actor class, as Pits are enemies, and therefore must stop the level from ending if there are any Pits alive in the world, and the StudentWorld needs a way to be aware of this. Therefore this function returns true instead of false.

// Bacteria
Bacteria() - My Bacteria constructor takes in an image ID, position, health value, and pointer to StudentWorld. It uses the base Actor constructor to initialize itself with the correct image ID, position, direction, depth, and StudentWorld pointer. It also initializes the health with the provided health value, the movement plan distance with 0, and the amount of food eaten with 0. 

~Bacteria() - My Bacteria destructor has an empty body, as there is no dynamically allocated data stored within the class. I chose to make it a pure virtual function as a way to tell that the class is an abstract base class.

isEnemy() - My Bacteria's isEnemy() function overrides the virtual function provided in the base Actor class, as Bacteria are enemies, and therefore must stop the level from ending if there are any Bacteria alive in the world, and the StudentWorld needs a way to be aware of this. Therefore this function returns true instead of false.

takeDamage() - My Bacteria's takeDamage() function overrides the virtual function provided in the base Actor class, as Bacteria have health points that allow them to take multiple hits before dying. The Bacteria's health is decremented by the indicated amount. If a Bacteria's health is 0 or less, then the function sets the Bacteria's status to dead and generates a random number between 1 and 2. If this number is 1 (50% chance), then a new Food actor is added to the spot where the Bacteria died. Then the function plays the correct death sound and increases the player's score by 100. If the Bacteria's health is still above 0, then the function plays the correct hurt sound.

isEColi() - My Bacteria's isEColi() function is a virtual function that tells the caller whether or not the Bacteria is specifically an EColi. I chose to make this virtual, as EColi have different sounds than the other bacteria, and I needed a way to tell takeDamage() when to play which sound.

ateFood() - My Bacteria's ateFood() function increments the amount of food eaten by 1, allowing the specific bacteria classes to modify Bacteria's private data member.

duplicate() - My Bacteria's duplicate() function takes in a reference to a position and returns if the Bacteria duplicated. It checks if the Bacteria has eaten 3 pieces of food. If it has, then it calculates the coordinates that the new Bacteria should be constructed with according to the spec. It then resets the amount of food the bacteria had eaten to 0 and returns true. If it had not eaten 3 pieces of food yet, the function returns false. This is in the Bacteria class because all types of bacteria have the same duplication process and requirements.

adjustForMPD() - My Bacteria's adjustForMPD() function checks if the Bacteria's MPD is greater than 0. If it is, the function will decrement the MPD by 1 and attempt to move 3 pixels in the desired direction. If it discovers that it is blocked from doing so, the Bacteria will pick a random direction to orient itself in, reset its MPD to 10, and return. If its MPD is 0, the Bacteria will check for the closest Food within 128 pixels. If no Food is discovered, it will pick a random direction to orient itself in and reset its MPD to 10. If Food was discovered, it will orient itself in the direction of the Food and reset its MPD to 10. This is in the Bacteria class because both Salmonella and AggSalmonella share this behavior.

// Salmonella
Salmonella() - My Salmonella constructor takes in a position and a pointer to StudentWorld. It uses the base Bacteria constructor to initialize itself with the correct image ID, position, health, and StudentWorld pointer. 

~Salmonella() - My Salmonella destructor has an empty body, as there is no dynamically allocated data stored within the class.

doSomething() - My Salmonella's doSomething() function returns if the Salmonella is dead. If not, the function checks if the Salmonella is overlapping with Socrates, and, if it is, tells the StudentWorld to deal 1 damage to him. If there is no overlap, the function checks if the Salmonella can duplicate using Bacteria's duplicate() function, and allocates a new Salmonella actor if it can. Otherwise, the function checks if the Salmonella is overlapping with food, and eats it if it is. Finally, the function calls Bacteria's checkForMPD() function to move.

// AggSalmonella
AggSalmonella() - My AggSalmonella constructor takes in a position and a pointer to StudentWorld. It uses the base Bacteria constructor to initialize itself with the correct image ID, position, health, and StudentWorld pointer. 

~AggSalmonella() - My AggSalmonella destructor has an empty body, as there is no dynamically allocated data stored within the class.

doSomething() - My AggSalmonella's doSomething() function returns if the AggSalmonella is dead. If not, the function checks if the AggSalmonella is within 72 pixels of Socrates, and, if it is, orients the AggSalmonella to point towards him. It will then try to move 3 pixels in that direction as long as it is not blocked by dirt or the border. It then sets a flag, telling the function to skip a later step. Then, the function checks if the AggSalmonella overlaps with Socrates, and, if it does, deals 2 damage to him. If there is no overlap, the function checks if the Salmonella can duplicate using Bacteria's duplicate() function, and allocates a new AggSalmonella actor if it can. Otherwise, the function checks if the Salmonella is overlapping with food, and eats it if it is. Finally, the function calls Bacteria's checkForMPD() function to move, as long as the flag was not set earlier.

// EColi
EColi() - My EColi constructor takes in a position and a pointer to StudentWorld. It uses the base Bacteria constructor to initialize itself with the correct image ID, position, health, and StudentWorld pointer. 

~EColi() - My EColi destructor has an empty body, as there is no dynamically allocated data stored within the class.

doSomething() - My EColi's doSomething() function returns if the EColi is dead. If not, the function checks if the EColi is overlapping with Socrates, and, if it is, tells the StudentWorld to deal 4 damage to him. If there is no overlap, the function checks if the EColi can duplicate using Bacteria's duplicate() function, and allocates a new EColi actor if it can. Otherwise, the function checks if the EColi is overlapping with food, and eats it if it is. Finally, the function checks if the EColi is within 256 pixels of Socrates, and, if it is, attempts to move towards him. If the EColi's path is blocked, then it will adjust its direction by 10 degrees and attempt to move again, up to 10 times.

isEColi() - My EColi's isEColi() function overrides the virtual function provided in the base Bacteria class, as EColi make different sounds upon being injured/dying. Therefore, this function returns true instead of false in order to tell Bacteria's takeDamage() function the right sound to produce.

// StudentWorld
~StudentWorld() - My StudentWorld destructor simply calls the cleanUp() function, as that function deallocates all remaining data when necessary.

init() - My StudentWorld's init() function begins by allocating a new Socrates actor. It then creates a number of Pits equal to the current level, checking to make sure they don't overlap with each other. Then it creates a number of Food actors equal to the minimum of 5 times the level and 25, doing the same check to make sure no Food actor overlaps with a Pit or another Food actor. Finally it creates a number of DirtPiles equal to the maximum of 180 minus 20 times the level and 20, doing the same check to make sure no DirtPile overlaps with a Pit or Food actor. Finally, the function returns a status that continues the game.

move() - My StudentWorld's move() function begins by calling the player's doSomething() function. Then, it iterates through the list of active actors, telling them each to doSomething() as long as they are alive. After each actor moves, the function checks if the player has died, and returns a status that ends the level if they have. Afterwards, the function once again iterates through the list of Actors, deleting and removing them from the list if they are now dead. Next, the function generates a chance to spawn Goodies/Fungi based on the level. Afterwards, it generates random numbers, and, if they are 0 (chance based on previously generated chances), a random position will be generated and a Goodie/Fungus will spawn. In the case of Goodies, another random number will be generated to determine if the goodie is a HealthKit, FlameCharge, or ExtraLife. Next, the function will update the display at the top of the screen by calling Socrates' accessor functions. Finally, the function will determine the correct status to return based on Socrates' alive status and the amount of enemies still alive.

cleanUp() - My StudentWorld's cleanUp() function begins by deleting the player. Then, it iterates through the list, deleting each Actor still present.

addActor() - My StudentWorld's addActor() function pushes a new Actor to the front of the list. This allows for Actors to add new Actors to the game, such as when Socrates shoots a projectile. 

checkHit() - My StudentWorld's checkHit() function returns whether or not the position it was passed overlaps with any damageable Actors by iterating through the list of active Actors and using the function isDamageable(). If it does, it will tell the Actor to take damage based on the damage value it was passed. 

eatFood() - My StudentWorld's eatFood() function returns whether or not the position it was passed overlaps with any Food actors by iterating through the list of active Actors and using the function isFood(). If it does, it will delete the selected Food actor from the list of Actors.

blocked() - My StudentWorld's blocked() function returns whether or not the position it was passed overlaps with any DirtPiles by iterating through the list of active Actors and using the function isDirt(). If not, the function returns whether or not the position is out of bounds of the petri dish.

findFood() - My StudentWorld's findFood() function returns whether or not the position it was passed is within 72 pixels of a Food actor by iterating through the list of active Actors and saving the closest Food object if one is found. If a food object is found, it will set the direction it was passed to the direction the Food object is in.

findSocrates() - My StudentWorld's findSocrates() function returns the distance between the position it was passed and Socrates. It also sets the direction it was passed equal to the direction Socrates is in relative to the position.

restoreHealth() - My StudentWorld's restoreHealth() function tells Socrates to call his heal() function. This is in the StudentWorld class in order for HealthKit to communicate with Socrates.

restoreFlames() - My StudentWorld's restoreFlames() function tells Socrates to call his regenFlames() function. This is in the StudentWorld class in order for FlameCharge to communicate with Socrates.

doDamage() - My StudentWorld's doDamage() function tells Socrates to call his takeDamage() function. This is in the StudentWorld class in order for enemies to communicate with Socrates.

2. Right now the biggest issue I have failed to address is the correct behavior for aggressive salmonella movement. They often seem to get stuck pointing in a direction and get trapped on the border of the play area. This also happens with E coli, as they share the same movement logic. As far as I know, this issue is due to them hitting the border of the petri dish in an orientation where moving forwards would take them out of bounds. As a result, they are blocked from moving forwards, but are also not allowed to re-orient themselves because they are chasing Socrates and must not attempt to find another path. Unfortunately, I cannot think of a solution to this issue. Another issue is that E coli will occasionally exhibit very jagged movement when approaching Socrates from certain angles. I have no idea what causes this issue.

3. I decided to use a list over a vector to contain my Actors in order to make it less taxing to delete Actors often, which the game must do every time an Actor dies. I also decided to create Bacteria, Projectile, and Goodies base class that derived from the Actor base class, as these types of Actors all shared common behavior. I decided to derive the Fungus class from Goodies, even though it isn't itself a Goodie, because it shared common behavior. I opted against creating another base class for Salmonella and Aggressive Salmonella, because the classes didn't share enough of the same behavior that wasn't already addressed in the Bacteria base class to make it worthwhile. 

4. 
// Actor 
The majority of the functions in my Actor class ended up being tested as I was testing my other functions, as most of them were virtual and worked correctly when they returned the correct values for the correct objects. I did have to make sure that my destructor was virtual so that cleanUp() functioned correctly, and that it was impossible to create an Actor object, as it was intended to be an abstract class.

// Socrates
To test my Socrates class, I first tested it before implementing any of the details in part 2. This allowed me to be sure that my movement was functional before moving on. The next thing I did was after implementing my Projectile classes, testing to see if the enter and space keys did as intended and allocated the correct Projectiles in the correct direction/position. Next, I implemented Goodies and ensured they would have the intended effects when overlapping with Socrates. Using the display, I could see my lives and flame charges go up when intended, took damage when overlapping with a fungus, and could heal up to 100 health with a health kit. This also told me that my data members/accessors were working as intended. The last thing to test was the collision and damage with bacteria. Since bacteria deal damage per tick, I needed to slow down the game to ensure they were dealing the right amount of damage and overlapping correctly.

// Dirt
To test my DirtPile class, I first needed to test that my doSomething was running and correctly not doing anything. Then I checked to make sure that I had correctly inherited and overridden isDirt() from my Actor class by calling it in StudentWorld and having it output to the console. After implementing the bacteria classes, I returned to this class to check that collisions functioned properly, using the slow-down mechanic to make sure no bacteria were passing through any dirt piles. 

// Food
To test my Food class, I first tested that doSomething was running by having it output something when it ran. Then, I checked to make sure I had correctly overridden isFood() and isDamageable so that bacteria could find and eat the food, and projectiles couldn't damage it. I also checked that food was correctly being eaten by bacteria by putting one salmonella into the game and allowing it to consume 3 pieces of food, after which it duplicated. I also tested that there was a chance for bacteria to drop food upon death by running multiple trials with all types of bacteria.

// Projectile
The majority of my Projectile class was tested in the testing of my Spray and Flame classes, as the class consists of virtual functions. One thing that I did have to test was that Projectiles couldn't be instantiated since it is an abstract base class. I also needed to make sure I made a virtual destructor so that Flames and Sprays could be deallocated correctly.

// Flame
While testing the Flame class, I was able to test Projectile's doSomething() function, which manages the movement of my projectiles. Using the eye test, I could see that the flames seemed to appear/disappear where they were supposed to relative to Socrates. Using bacteria and an output in their takeDamage() function, I was also able to see that the flames did damage and that damage was the right amount. Through this, I confirmed that pressing the enter key created a ring of flames around Socrates, played the correct sound and drained his flame ammo by 1. The visuals also confirmed that the constructor worked properly.

// Spray
While testing the Spray class, I was able to test Projectile's doSomething() function again. I could see that the sprays seemed to appear/disappear where they were supposed to relative to Socrates. Using bacteria and an output in their takeDamage() function, I was also able to see that the sprays did damage and that damage was the right amount. Through this, I confirmed that pressing the space key fired a spray, played the correct sound, and decremented Socrates' spray ammo by 1. The visuals also confirmed that the constructor worked properly.

// Goodies
Much like my Projectile and Actor classes, my Goodies class was primarily tested through the testing of other classes, as its only function is doSomething(), which is called on its derived classes. As a result, the only tests I did specifically for Goodies were testing that it could not be instantiated as it is an abstract base class, and that its destructor was virtual so that Goodies could get deallocated properly.

// HealthKit
In order to test my HealthKit class, I first had my move() function in StudentWorld output something every time a health kit was created. This way, I could ensure that they were spawning in the correct locations (on the edge of the dish). After this, I found ways to damage myself, and then overlapped with a health kit to make sure that they did their intended effect of healing Socrates, played the correct sound, and added the correct score. I finally used the eye test to see that they were disappearing after a reasonable time.

// FlameCharge
In order to test my FlameCharge class, I first had my move() function in StudentWorld output something every time a flame charge was created. This way, I could ensure that they were spawning in the correct locations (on the edge of the dish). After this, I overlapped with a flame charge to make sure that they did their intended effect of giving Socrates 5 more flamethrower ammo, played the correct sound, and added the correct score. I finally used the eye test to see that they were disappearing after a reasonable time.

// ExtraLife
In order to test my ExtraLife class, I first had my move() function in StudentWorld output something every time an extra life was created. This way, I could ensure that they were spawning in the correct locations (on the edge of the dish). After this, I overlapped with an extra life to make sure that they did their intended effect of giving Socrates an extra life, played the correct sound, and added the correct score. I finally used the eye test to see that they were disappearing after a reasonable time.

// Fungus
In order to test my Fungus class, I first had my move() function in StudentWorld output something every time a fungus was created. This way, I could ensure that they were spawning in the correct locations (on the edge of the dish). After this, I overlapped with a fungus to make sure that they did their intended effect of healing Socrates, played the correct sound, and decremented the correct score. I finally used the eye test to see that they were disappearing after a reasonable time.

// Pit
To test my Pit class, I first checked that the correct number of pits spawned based on the level, and that their random spawn location were valid across multiple instances. I then proved to myself that each pit would only spawn 10 bacteria, with the correct amount of each type of bacteria. I also had to check that pits stopped the level from finished, and I did so by having no bacteria present, and making sure the level didn't instantly end. Throughout multiple tests, I saw that the bacteria generally came out at the same probability and a reasonable frequency. During these tests, I also saw that the pit played the right sound for creating bacteria.

// Bacteria
Like my other abstract base classes, I relied on the testing of the derived classes to test this class' functions. This meant that I just had to make sure that a Bacteria could not be instantiated, and that the destructor was a virtual destructor so that the bacteria types could deallocate properly.

// Salmonella
To begin testing my Salmonella class, I first stopped it from doing damage so I could observe its movement without having to dodge it. I noticed that it correctly got blocked by dirt and the border of the petri dish, and was capable of eating food. Over time, I saw it successfully duplicate and redirect itself towards food objects. I then initiated a game where no pits spawned and a Salmonella did to make sure the world recognized it as an enemy and didn't end the level immediately. These observations proved that my adjustForMPD(), duplicate(), ateFood(), and isEnemy() functions in my Bacteria class worked at least close to how I intended to implement them. I then allowed the Salmonella to deal damage to the player, and observed the correct damage values being dealt. Finally, I tested killing the Salmonella, ensuring they produced the right injury and death sounds, increased the score, and occasionally dropped food.

// AggSalmonella
To begin testing my AggSalmonella class, I first stopped it from doing damage so I could observe its movement without having to dodge it. I noticed that it correctly got blocked by dirt, was capable of eating food, and redirected itself towards Socrates when necessary. However it struggled to move and orient itself correctly when chasing Socrates on the border of the petri dish. Over time, I saw it successfully duplicate and redirect itself towards food objects. I then initiated a game where no pits spawned and a AggSalmonella did to make sure the world recognized it as an enemy and didn't end the level immediately. I then allowed the AggSalmonella to deal damage to the player, and observed the correct damage values being dealt. Finally, I tested killing the AggSalmonella, ensuring they produced the right injury and death sounds, increased the score, and occasionally dropped food. 

// EColi
To begin testing my EColi class, I first stopped it from doing damage so I could observe its movement without having to dodge it. I noticed that it correctly got blocked by dirt, was capable of eating food, and redirected itself towards Socrates when necessary. However it struggled to move and orient itself correctly when chasing Socrates on the border of the petri dish. In addition its movement was very jagged when approaching Socrates from certain directions. Over time, I saw it successfully duplicate and ignore food objects. I then initiated a game where no pits spawned and an EColi did to make sure the world recognized it as an enemy and didn't end the level immediately. I then allowed the EColi to deal damage to the player, and observed the correct damage values being dealt. Finally, I tested killing the EColi, ensuring they produced the right injury and death sounds, increased the score, and occasionally dropped food. This proved my isEColi() function worked as intended.

// StudentWorld
The StudentWorld class ended up getting tested with all the other classes, as they all required StudentWorld's functions to be operating in order to communicate with each other. The first function I tested was the init() function. Socrates was initialized in the right position, and the correct amount of pits, dirt, and food were created with no incorrect overlap. Next, move() was tested as all the classes were, considering move() managed doSomething for all the actors, tracking game status, placing goodies/fungi, and creating the display. Finally, I tested cleanUp() under all 3 conditions: a level end, a lost life screen, and a game over screen. As I got no errors/crashes in these situations, I continued under the assumption that my destructor functioned properly. In addition, the utility functions I implemented to help actors check on other actors (blocked(), findFood(), findSocrates(), etc.) all were tested as the classes they involved were tested (bacteria using blocked() to detect dirt, bacteria using findFood()/findSocrates() to orient themselves, etc.)
